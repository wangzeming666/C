一元运算符&可用于取一个对象的地址,因此,下列语句:
p = &c;
将把 c 的地址赋值给变量 p,我们称 p 为“指向”c 的指针。地址运算符&只能应用于内存中
的对象,即变量与数组元素。它不能作用于表达式、常量或 register 类型的变量。

一元运算符*是间接寻址或间接引用运算符。当它作用于指针时,将访问指针所指向的对象。

int x = 1, y = 2, z[10];

int *ip;        /* ip is a pointer to int */1
ip = &x;		    /* ip now points to x */
y = *ip;		    /* y is now 1 */
*ip = 0;	    	/* x is now 0 */
ip = &z[0];	  	/* ip now points to z[0] */

int *ip;
这样声明是为了便于记忆。该声明语句表明表达式*ip 的结果是 int 类型。

我们应该注意,指针只能指向某种特定类型的对象,也就是说,每个指针都必须指向某
种特定的数据类型。
(一个例外情况是指向 void 类型的指针可以存放指向任何类型的指针,
但它不能间接引用其自身。

一元运算符*和&的优先级比算术运算符的优先级高,因此,赋值语句
y = *ip + 1
将把*ip 指向的对象的值取出并加 1,然后再将结果赋值给 y,而下列赋值语句:
*ip += 1
则将 ip 指向的对象的值加 1,它等同于
++*ip
或
(*ip)++
语句的执行结果。语句(*ip)++中的圆括号是必需的, 否则, 该表达式将对 ip 进行加 1 运算,
而不是对 ip 指向的对象进行加 1 运算,这是因为,类似于*和++这样的一元运算符遵循从右
至左的结合顺序。

最后说明一点,由于指针也是变量,所以在程序中可以直接使用,而不必通过间接引用
的方法使用。例如,如果 iq 是另一个指向整型的指针,那么语句
iq = ip
将把 ip 中的值拷贝到 iq 中,这样,指针 iq 也将指向 ip 指向的对象。

