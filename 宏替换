宏定义的形式如下:
#define 名字 替换文本

这是一种最简单的宏替换——后续所有出现名字记号的地方都将被替换为替换文本。

#define 指令中的名字与变量名的命名方式相同, 替换文本可以是任意字符串。通常情况下,
#define 指令占一行, 替换文本是 #define 指令行尾部的所有剩余部分内容, 但也可以把一
个较长的宏定义分成若干行,这时需要在待续的行末尾加上一个反斜杠符\。

#define 指令定义的名字的作用域从其定义点开始,到被编译的源文件的末尾处结束。

宏定义中也可以使用前面出现的宏定义。替换只对记号进行,对括在引号中的字符串不起作用。
例如,如果 YES 是一个通过#define 指令定义过的名字,
则在 printf("YES")或 YESMAN 中将不执行替换。

替换文本可以是任意的,例如:
#define forever for (;;)
/* infinite loop */
该语句为无限循环定义了一个新名字 forever。

宏定义也可以带参数,这样可以对不同的宏调用使用不同的替换文本。例如,下列宏定
义定义了一个宏 max:
#define max(A, B) ((A) > (B) ? (A) : (B))
仔细考虑一下 max 的展开式,就会发现它存在一些缺陷。其中,作为参数的表达式要重
复计算两次,如果表达式存在副作用(比如含有自增运算符或输入/输出)
,则会出现不正确的情况。例如:
max(i++, j++) /* WRONG */
它将对每个参数执行两次自增操作。同时还必须注意,要适当使用圆括号以保证计算次序的
正确性。
考虑下列宏定义:
#define square(x) x * x /* WRONG */
当用 squrare(z+1)调用该宏定义时会出现什么情况呢?

但是,宏还是很有价值的。<stdio.h>头文件中有一个很实用的例子:getchar 与
putchar 函数在实际中常常被定义为宏,这样可以避免处理字符时调用函数所需的运行时开
销。<ctype.h>头文件中定义的函数也常常是通过宏实现的。

可以通过#undef 指令取消名字的宏定义, 这样做可以保证后续的调用是函数调用, 而不
是宏调用:
#undef getchar
int getchar(void) { ... }

形式参数不能用带引号的字符串替换。但是,如果在替换文本中,参数名以#作为前缀则
结果将被扩展为由实际参数替换该参数的带引号的字符串。例如,可以将它与字符串连接运
算结合起来编写一个调试打印宏:
#define dprint(expr)
printf(#expr " = %g\n", expr)
使用语句
dprint(x/y)
调用该宏时,该宏将被扩展为:
printf("x/y" " = &g\n", x/y);
其中的字符串被连接起来了,这样,该宏调用的效果等价于
printf("x/y = &g\n", x/y);
在实际参数中,每个双引号"将被替换为\",反斜杠\将被替换为\\,因此替换后的字符串是
合法的字符串常量。

预处理器运算符##为宏扩展提供了一种连接实际参数的手段。如果替换文本中的参数与
##相邻,则该参数将被实际参数替换,##与前后的空白符将被删除,并对替换后的结果重新
扫描。例如,下面定义的宏 paste 用于连接两个参数
#define paste(front, back) front ## back
因此,宏调用 paste(name, 1)的结果将建立记号 name1。
##的嵌套使用规则比较难以掌握,详细细节请查阅文档。
