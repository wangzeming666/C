结构的合法操作只有几种: 作为一个整体复制和赋值,通过&运算符取地址, 访问其成员。
其中,复制和赋值包括向函数传递参数以及从函数返回值。结构之间不可以进行比较。可以
用一个常量成员值列表初始化结构,自动结构也可以通过赋值进行初始化。

如果传递给函数的结构很大,使用指针方式的效率通常比复制整个结构的效率要高。结
构指针类似于普通变量指针。声明
struct point *pp;
将 pp 定义为一个指向 struct point 类型对象的指针。如果 pp 指向一个 point 结构,那
么*pp 即为该结构, 而(*pp).x 和(*pp).y 则是结构成员。

其中,(*pp).x 中的圆括号是必需的,因为结构成员运算符“.”的优先级比“*”的优先级
高。表达式*pp.x 的含义等价于*(pp.x),因为 x 不是指针,所以该表达式是非法的。

结构指针的使用频度非常高,为了使用方便,C 语言提供了另一种简写方式。假定 p 是
一个指向结构的指针,可以用
p->结构成员
这种形式引用相应的结构成员。这样,就可以用下面的形式改写上面的一行代码:
printf("origin is (%d,%d)\n", pp->x, pp->y);
运算符.和->都是从左至右结合的,所以,对于下面的声明:
struct rect r, *rp = &r;
以下 4 个表达式是等价的:
r.pt1.x
rp->pt1.x
(r.pt1).x
(rp->pt1).x
在所有运算符中,下面 4 个运算符的优先级最高:结构运算符“.”和“->”
、用于函数
调用的“()”以及用于下标的“[]” ,因此,它们同操作数之间的结合也最紧密。例如,对于
结构声明
struct {
int len;
char *str;
} *p;
表达式
++p->len
将增加 len 的值,而不是增加 p 的值,这是田为,其中的隐含括号关系是++(p->len)。可
以使用括号改变结合次序。

同样,*p->str 读取的是指针 str 所指向的对象的值;*p->str++先读取指针
str 指向的对象的值,然后再将 str 加 1(与*s++相同)
;(*p->str)++将指针 str 指向
的对象的值加 1;*p++->str 先读取指针 str 指向的对象的值,然后再将 p 加 1。
