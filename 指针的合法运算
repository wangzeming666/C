可以将指向子数组起始位置的指针传递给函数,这样,就将数组的一部分传递给了函
数。例如,如果 a 是一个数组,那么下面两个函数调用
f(&a[2])
与
f(a+2)
都将把起始于 a[2]的子数组的地址传递给函数 f。

如果确信相应的元素存在,也可以通过下标访问数组第一个元素之前的元素。类似于
p[-1]、 p[-2]这样的表达式在语法上都是合法的, 它们分别引用位于 p[0]之前的两个元素。
当然,引用数组边界之外的对象是非法的。

C 语言保证,0 永远不是有效的数据地址,因此,返回值 0 可用来表示发生了异常事件。

指针与整数之间不能相互转换,但 0 是惟一的例外:常量 0 可以赋值给指针,指针也可
以和常量 0 进行比较。程序中经常用符号常量 NULL 代替常量 0,这样便于更清晰地说明常量
0 是指针的一个特殊值。符号常量 NULL 定义在标准头文件<stddef.h>中。

在某些情况下对指针可以进
行比较运算。例如,如果指针 p 和 q 指向同一个数组的成员,那么它们之间就可以进行类似
于==、!=、<、>=的关系比较运算。如果 p 指向的数组元素的位置在 q 指向的数组元素位置
之前,那么关系表达式
p < q
的值为真。任何指针与 0 进行相等或不等的比较运算都有意义。但是,指向不同数组的元素
的指针之间的算术或比较运算没有定义。
(这里有一个特例:指针的算术运算中可使用数组最
后一个元素的下一个元素的地址。)

其次。我们从前面可以看到,指针可以和整数进行相加或相减运算。例如,结构
p + n
表示指针 p 当前指向的对象之后第 n 个对象的地址。无论指针 p 指向的对象是何种类型,上
述结论都成立。在计算 p+n 时,n 将根据 p 指向的对象的长度按比例缩放,而 p 指向的对象
的长度则取决于 p 的声明。例如,如果 int 类型占 4 个字节的存储空间,那么在 int 类型的
计算中,对应的 n 将按 4 的倍数来计算。

指针的减法运算也是有意义的: 如果 p 和 q 指向相同数组中的元索, 且 p<q, 那么 q-p+1
就是位于 p 和 q 指向的元索之间的元素的数目。

指针的算术运算具有一致性:如果处理的数据类型是比字符型占据更多存储空间的浮点
类型,并且 p 是一个指向浮点类型的指针,那么在执行 p++后,p 将指向下一个浮点数的地
址。所有的指针运算都会自动考虑它所指向的对象的长度。

有效的指针运算包括相同类型指针之间的赋值运算;指针同整数之间的加法或减法运算;
指向相同数组中元素的两个指针间的减法或比较运算;将指针赋值为 0 或指针与 0 之间的比
较运算。其它所有形式的指针运算都是非法的,例如两个指针间的加法、乘法、除法、移位
或屏蔽运算;指针同 float 或 double 类型之间的加法运算;不经强制类型转换而直接将指
向一种类型对象的指针赋值给指向另一种类型对象的指针的运算(两个指针之一是 void *
类型的情况除外)。
